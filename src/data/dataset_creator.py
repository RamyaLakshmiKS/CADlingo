"""
Dataset Creator for CADlingo

Generates training pairs of (natural language description, AutoCAD code) from RPLAN floor plans.

This module:
1. Loads RPLAN floor plans
2. Generates natural language descriptions
3. Converts floor plans to AutoCAD LISP commands
4. Creates train/val/test splits
5. Saves datasets for model training

"""

import os
import json
import pickle
from pathlib import Path
from typing import Dict, List, Tuple, Any
import random
from tqdm import tqdm
import numpy as np

from rplan_loader import RPlanLoader


class AutoCADCodeGenerator:
    """
    Generates AutoCAD LISP code from parsed floor plan data.
    """
    
    # Scale factor (RPLAN units to feet/meters)
    SCALE = 0.1
    
    def __init__(self, unit: str = "feet"):
        """
        Initialize code generator.
        
        Args:
            unit: 'feet' or 'meters'
        """
        self.unit = unit
    
    def generate_code(self, floor_plan: Dict[str, Any]) -> str:
        """
        Generate AutoCAD LISP code for a floor plan.
        
        Args:
            floor_plan: Parsed floor plan dictionary
            
        Returns:
            AutoCAD LISP code as string
        """
        code_lines = []
        
        # Header comments
        code_lines.append("; AutoCAD LISP code for floor plan")
        code_lines.append("; Generated by CADlingo")
        code_lines.append("")
        
        # Set up units and environment
        code_lines.append("; Setup")
        code_lines.append("(command \"UNITS\" \"2\" \"64\" \"1\" \"1\" \"0\" \"N\")")
        code_lines.append("")
        
        # Create layers for different elements
        code_lines.append("; Create layers")
        code_lines.append("(command \"LAYER\" \"N\" \"WALLS\" \"C\" \"7\" \"WALLS\" \"\")")
        code_lines.append("(command \"LAYER\" \"N\" \"DOORS\" \"C\" \"3\" \"DOORS\" \"\")")
        code_lines.append("(command \"LAYER\" \"N\" \"ROOMS\" \"C\" \"4\" \"ROOMS\" \"\")")
        code_lines.append("")
        
        # Draw walls first (from room boundaries)
        code_lines.append("; Draw walls")
        code_lines.append("(command \"LAYER\" \"S\" \"WALLS\" \"\")")
        
        for room in floor_plan['rooms']:
            if room['vertices'] and len(room['vertices']) > 2:
                vertices = [(v[0] * self.SCALE, v[1] * self.SCALE) for v in room['vertices']]
                
                # Draw polyline for room boundary
                code_lines.append(f"; Room: {room['type']}")
                pline_cmd = "(command \"PLINE\""
                for v in vertices:
                    pline_cmd += f" (list {v[0]:.2f} {v[1]:.2f})"
                pline_cmd += " \"C\")"  # Close polyline
                code_lines.append(pline_cmd)
        
        code_lines.append("")
        
        # Add room labels
        code_lines.append("; Add room labels")
        code_lines.append("(command \"LAYER\" \"S\" \"ROOMS\" \"\")")
        
        for room in floor_plan['rooms']:
            if room['center']:
                center = (room['center'][0] * self.SCALE, room['center'][1] * self.SCALE)
                label = room['type'].replace('_', ' ').title()
                code_lines.append(f"(command \"TEXT\" (list {center[0]:.2f} {center[1]:.2f}) \"2.5\" \"0\" \"{label}\")")
        
        code_lines.append("")
        
        # Add doors if available
        if floor_plan['doors']:
            code_lines.append("; Add doors")
            code_lines.append("(command \"LAYER\" \"S\" \"DOORS\" \"\")")
            
            for door in floor_plan['doors']:
                if door['position']:
                    pos = (door['position'][0] * self.SCALE, door['position'][1] * self.SCALE)
                    # Draw a simple arc for door swing
                    code_lines.append(f"(command \"CIRCLE\" (list {pos[0]:.2f} {pos[1]:.2f}) \"1.5\")")
        
        code_lines.append("")
        
        # Zoom to extents
        code_lines.append("; Zoom to fit")
        code_lines.append("(command \"ZOOM\" \"E\")")
        code_lines.append("")
        code_lines.append("; End of file")
        
        return "\n".join(code_lines)
    
    def generate_simplified_code(self, floor_plan: Dict[str, Any]) -> str:
        """
        Generate simplified AutoCAD code (for easier model learning)
        
        Format:
        LAYER WALLS
        RECT x1 y1 x2 y2  ; room1
        RECT x1 y1 x2 y2  ; room2
        TEXT x y "Label"
        
        Args:
            floor_plan: Parsed floor plan dictionary
            
        Returns:
            Simplified code string
        """
        code_lines = []
        
        code_lines.append("LAYER WALLS")
        
        # Draw rooms as rectangles (simplified from polygons)
        for room in floor_plan['rooms']:
            if room['bbox']:
                bbox = room['bbox']
                x1 = bbox['min_x'] * self.SCALE
                y1 = bbox['min_y'] * self.SCALE
                x2 = bbox['max_x'] * self.SCALE
                y2 = bbox['max_y'] * self.SCALE
                
                code_lines.append(f"RECT {x1:.1f} {y1:.1f} {x2:.1f} {y2:.1f}  ; {room['type']}")
        
        # Add labels
        code_lines.append("LAYER LABELS")
        for room in floor_plan['rooms']:
            if room['center']:
                x = room['center'][0] * self.SCALE
                y = room['center'][1] * self.SCALE
                label = room['type'].replace('_', ' ').title()
                code_lines.append(f"TEXT {x:.1f} {y:.1f} \"{label}\"")
        
        return "\n".join(code_lines)


class DescriptionGenerator:
    """
    Generates natural language descriptions from floor plan data.
    """
    
    def __init__(self):
        # Templates for variety
        self.templates = [
            "A {total_area} sq ft floor plan with {room_list}",
            "Floor plan featuring {room_list}, total area {total_area} sq ft",
            "{room_count} room floor plan: {room_list}",
            "Residential floor plan with {room_list}, approximately {total_area} sq ft",
            "{room_list} in a {total_area} sq ft layout"
        ]
    
    def generate_description(self, floor_plan: Dict[str, Any]) -> str:
        """
        Generate natural language description from floor plan.
        
        Args:
            floor_plan: Parsed floor plan dictionary
            
        Returns:
            Natural language description
        """
        rooms = floor_plan['rooms']
        
        # Count room types
        room_counts = {}
        total_area = 0
        
        for room in rooms:
            room_type = room['type']
            # Skip walls and exterior
            if room_type in ['exterior', 'exterior_wall', 'interior_wall']:
                continue
            
            room_counts[room_type] = room_counts.get(room_type, 0) + 1
            total_area += room['area']
        
        # Scale area
        total_area = total_area * (0.1 ** 2)  # Convert to sq ft approximately
        
        # Create room list string
        room_parts = []
        for room_type, count in sorted(room_counts.items()):
            clean_name = room_type.replace('_', ' ')
            if count > 1:
                room_parts.append(f"{count} {clean_name}s")
            else:
                room_parts.append(f"{count} {clean_name}")
        
        if len(room_parts) == 0:
            room_list = "multiple rooms"
        elif len(room_parts) == 1:
            room_list = room_parts[0]
        elif len(room_parts) == 2:
            room_list = f"{room_parts[0]} and {room_parts[1]}"
        else:
            room_list = ", ".join(room_parts[:-1]) + f", and {room_parts[-1]}"
        
        # Select random template
        template = random.choice(self.templates)
        
        description = template.format(
            total_area=int(total_area),
            room_list=room_list,
            room_count=sum(room_counts.values())
        )
        
        return description


class CADDatasetCreator:
    """
    Creates training dataset for text-to-CAD generation.
    """
    
    def __init__(self, data_root: str = None, output_root: str = None):
        """
        Initialize dataset creator.
        
        Args:
            data_root: Path to RPLAN data
            output_root: Path to save processed datasets
        """
        self.loader = RPlanLoader(data_root)
        
        if output_root is None:
            project_root = Path(__file__).parent.parent.parent
            output_root = project_root / "data" / "processed"
        
        self.output_root = Path(output_root)
        self.output_root.mkdir(parents=True, exist_ok=True)
        
        self.code_generator = AutoCADCodeGenerator()
        self.desc_generator = DescriptionGenerator()
    
    def create_dataset(
        self, 
        split: str = "train",
        max_samples: int = None,
        code_format: str = "simplified"
    ) -> List[Dict[str, str]]:
        """
        Create dataset from RPLAN data.
        
        Args:
            split: 'train' or 'val'
            max_samples: Maximum number of samples (None = all)
            code_format: 'simplified' or 'full' LISP code
            
        Returns:
            List of {description, code, metadata} dictionaries
        """
        print(f"\nCreating {split} dataset...")
        
        # Load floor plans
        file_list = self.loader.get_file_list(split)
        if max_samples:
            file_list = file_list[:max_samples]
        
        print(f"Loading {len(file_list)} floor plans...")
        floor_plans = self.loader.load_batch(file_list)
        
        # Generate dataset
        dataset = []
        
        for plan in tqdm(floor_plans, desc=f"Processing {split}"):
            # Skip plans with no rooms
            if not plan['rooms'] or len(plan['rooms']) == 0:
                continue
            
            # Generate description
            description = self.desc_generator.generate_description(plan)
            
            # Generate code
            if code_format == "simplified":
                code = self.code_generator.generate_simplified_code(plan)
            else:
                code = self.code_generator.generate_code(plan)
            
            # Create dataset entry
            entry = {
                "description": description,
                "code": code,
                "metadata": {
                    "source_file": plan['file_name'],
                    "num_rooms": len(plan['rooms']),
                    "room_types": [r['type'] for r in plan['rooms']],
                    "dimensions": plan['dimensions']
                }
            }
            
            dataset.append(entry)
        
        print(f"Created {len(dataset)} training pairs")
        return dataset
    
    def save_dataset(self, dataset: List[Dict], split: str, format: str = "json"):
        """
        Save dataset to disk.
        
        Args:
            dataset: List of dataset entries
            split: 'train', 'val', or 'test'
            format: 'json' or 'pickle'
        """
        if format == "json":
            output_file = self.output_root / f"{split}_dataset.json"
            with open(output_file, 'w') as f:
                json.dump(dataset, f, indent=2)
            print(f"Saved to {output_file}")
        
        elif format == "pickle":
            output_file = self.output_root / f"{split}_dataset.pkl"
            with open(output_file, 'wb') as f:
                pickle.dump(dataset, f)
            print(f"Saved to {output_file}")
        
        # Also save a text version for easy inspection
        text_file = self.output_root / f"{split}_samples.txt"
        with open(text_file, 'w') as f:
            for i, entry in enumerate(dataset[:10]):  # Save first 10 samples
                f.write(f"=== Sample {i+1} ===\n")
                f.write(f"Description: {entry['description']}\n")
                f.write(f"Code:\n{entry['code']}\n")
                f.write("\n" + "="*50 + "\n\n")
        print(f"Saved samples to {text_file}")
    
    def create_full_pipeline(
        self, 
        train_samples: int = 1000,
        val_samples: int = 200,
        code_format: str = "simplified"
    ):
        """
        Run full dataset creation pipeline.
        
        Args:
            train_samples: Number of training samples
            val_samples: Number of validation samples
            code_format: 'simplified' or 'full'
        """
        print("="*60)
        print("CADlingo Dataset Creation Pipeline")
        print("="*60)
        
        # Create training set
        train_dataset = self.create_dataset("train", train_samples, code_format)
        self.save_dataset(train_dataset, "train", format="json")
        
        # Create validation set
        val_dataset = self.create_dataset("val", val_samples, code_format)
        self.save_dataset(val_dataset, "val", format="json")
        
        # Print statistics
        print("\n" + "="*60)
        print("Dataset Statistics:")
        print("="*60)
        print(f"Training samples: {len(train_dataset)}")
        print(f"Validation samples: {len(val_dataset)}")
        
        # Average code length
        avg_code_len = np.mean([len(entry['code']) for entry in train_dataset])
        avg_desc_len = np.mean([len(entry['description']) for entry in train_dataset])
        
        print(f"\nAverage description length: {avg_desc_len:.1f} characters")
        print(f"Average code length: {avg_code_len:.1f} characters")
        
        # Sample output
        print("\n" + "="*60)
        print("Sample Output:")
        print("="*60)
        sample = train_dataset[0]
        print(f"\nDescription:\n{sample['description']}")
        print(f"\nGenerated Code:\n{sample['code'][:500]}...")
        
        print("\nDataset creation complete!")
        print(f"Output saved to: {self.output_root}")


def main():
    """Main execution function."""
    # Create dataset with reasonable defaults
    creator = CADDatasetCreator()
    
    # Create dataset (start with smaller numbers for testing)
    creator.create_full_pipeline(
        train_samples=1000,   
        val_samples=200,      
        code_format="simplified"  
    )


if __name__ == "__main__":
    main()
